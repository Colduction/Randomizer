package randomizer

import (
	"bytes"
	"strings"
)

const (
	deci     string = "0123456789"
	lhexdict string = "0123456789abcdef"
	uhexdict string = "0123456789ABCDEF"
)

type word struct{}

var Word word

// Decimal generates a random numeric string of the specified length,
// consisting of characters from "0123456789".
func (word) Decimal(length int) string {
	if length <= 0 {
		return ""
	}
	var sb strings.Builder
	sb.Grow(length)
	for i, hash := 0, uint64(0); i < length; i++ {
		if i&7 == 0 {
			hash = DefaultHashPool.Sum64()
			for j, digit := 0, uint64(0); j < 8 && (i+j) < length; j++ {
				digit = (hash >> (j * 4)) % 10
				sb.WriteByte(deci[digit])
			}
			i += 7
		}
	}
	return sb.String()
}

// DecimalBytes generates a random numeric byte slice of the specified length,
// consisting of digits from "0123456789".
func (word) DecimalBytes(length int) []byte {
	if length <= 0 {
		return nil
	}
	var bb bytes.Buffer
	bb.Grow(length)
	for i, hash := 0, uint64(0); i < length; i++ {
		if i&7 == 0 {
			hash = DefaultHashPool.Sum64()
			for j, digit := 0, uint64(0); j < 8 && (i+j) < length; j++ {
				digit = (hash >> (j * 4)) % 10
				bb.WriteByte(deci[digit])
			}
			i += 7
		}
	}
	return bb.Bytes()
}

// Hex generates a random hexadecimal string of the specified length.
// If the uppercase parameter is true, the generated string will use uppercase letters (A-F),
// otherwise, it will use lowercase letters (a-f).
func (word) Hex(length int, uppercase bool) string {
	if length <= 0 {
		return ""
	}
	var sb strings.Builder
	sb.Grow(length)
	for i, hash := 0, uint64(0); i < length; i++ {
		if i&7 == 0 {
			hash = DefaultHashPool.Sum64()
			for j, digit := 0, uint64(0); j < 8 && (i+j) < length; j++ {
				digit = (hash >> (j * 4)) & 0x0F
				if uppercase {
					sb.WriteByte(uhexdict[digit])
					continue
				}
				sb.WriteByte(lhexdict[digit])
			}
			i += 7
		}
	}
	return sb.String()
}

// HexBytes generates a random hexadecimal byte slice of the specified length.
// If the uppercase parameter is true, the generated bytes will use uppercase letters (A-F),
// otherwise, it will use lowercase letters (a-f).
func (word) HexBytes(length int, uppercase bool) []byte {
	if length <= 0 {
		return nil
	}
	var bb bytes.Buffer
	bb.Grow(length)
	for i, hash := 0, uint64(0); i < length; i++ {
		if i&7 == 0 {
			hash = DefaultHashPool.Sum64()
			for j, digit := 0, uint64(0); j < 8 && (i+j) < length; j++ {
				digit = (hash >> (j * 4)) & 0x0F
				if uppercase {
					bb.WriteByte(uhexdict[digit])
					continue
				}
				bb.WriteByte(lhexdict[digit])
			}
			i += 7
		}
	}
	return bb.Bytes()
}

// Octal generates a random octal string of the specified length,
// consisting of characters from "01234567".
func (word) Octal(length int) string {
	if length <= 0 {
		return ""
	}
	var sb strings.Builder
	sb.Grow(length)
	for i, hash := 0, uint64(0); i < length; i++ {
		if i&7 == 0 {
			hash = DefaultHashPool.Sum64()
			for j, digit := 0, uint64(0); j < 8 && (i+j) < length; j++ {
				digit = (hash >> (j * 3)) & 0x7
				sb.WriteByte(deci[digit])
			}
			i += 7
		}
	}
	return sb.String()
}

// OctalBytes generates a random octal byte slice of the specified length,
// consisting of digits from "01234567".
func (word) OctalBytes(length int) []byte {
	if length <= 0 {
		return nil
	}
	var bb bytes.Buffer
	bb.Grow(length)
	for i, hash := 0, uint64(0); i < length; i++ {
		if i&7 == 0 {
			hash = DefaultHashPool.Sum64()
			for j, digit := 0, uint64(0); j < 8 && (i+j) < length; j++ {
				digit = (hash >> (j * 3)) & 0x7
				bb.WriteByte(deci[digit])
			}
			i += 7
		}
	}
	return bb.Bytes()
}
